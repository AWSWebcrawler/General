"""The item factory parses the passed html text and extracts the desired attributes. The attributes are then stored in a
dictionary and returned."""

import locale
import logging
import re
import time
from datetime import datetime
from io import StringIO

from lxml import etree

from crawler.logging.decorator import decorator_for_logging


@decorator_for_logging
def create_item(html: str, url: str, function_name_with_html: dict) -> dict:
    """The dictionary contains the attributes as name:value pairs. The value is generated by a method call.
    The individual methods receive the html text. Select the correct values using the appropriate html tags.
    Validate whether the values make any sense at all and, if necessary, transform the values to get the
    desired return value."""

    logging.debug("Calling the create_item function")

    datetime_now = datetime.now()

    parser = etree.HTMLParser()
    tree = etree.parse(StringIO(html), parser)

    logging.debug("Tree is created from the parsed html")

    dic = {
        "name": _check_return_value(
            _get_name(tree), "get_name", function_name_with_html, html, tree
        ),
        "current_price": _check_return_value(
            _get_current_price(tree),
            "get_current_price",
            function_name_with_html,
            html,
            tree,
        ),
        "price_regular": _get_regular_price(tree),
        "prime": _get_prime(tree),
        "discount_in_euros": _get_discount_in_euros(tree),
        "percent_discount": _get_percent_discount(tree),
        "sold_by_amazon": _get_sold_by_amazon(tree),
        "seller": _get_seller(tree),
        "brand": _get_brand(tree),
        "shipping": _get_shipping(tree),
        "amazon_choice": _get_amazon_choice(tree),
        "amazon_choice_for": _get_amazon_choice_for(tree),
        "asin": _check_return_value(
            _get_asin(tree), "get_asin", function_name_with_html, html, tree
        ),
        "product_id": _get_product_id(tree),
        "manufacturer": _get_manufacturer(tree),
        "country_of_origin": _get_country_of_origin(tree),
        "product_dimensions": _get_product_dimensions(tree),
        "number_of_reviews": _get_number_of_reviews(tree),
        "review_score": _get_review_score(tree),
        "on_sale_since": _get_on_sale_since(tree),
        "url": _check_return_value(
            _get_url(url), "_get_url", function_name_with_html, html, tree
        ),
        "timestamp": _get_timestamp(datetime_now),
        "date": _get_date(datetime_now),
        "time": _get_time(datetime_now),
    }

    return dic


@decorator_for_logging
def _check_return_value(
    value, function_name, html_with_error: dict, html: str, tree: etree
):
    """Adding the html to the error list if an important item was not found."""
    if value is None:
        if not out_of_stock(tree):
            if function_name in html_with_error.keys():
                html_with_error[function_name].append(html)
            else:
                html_with_error[function_name] = [html]
    return value


@decorator_for_logging
def out_of_stock(tree: etree) -> bool:
    """Checking if the product is out of stock"""

    div_tag = tree.find('.//div[@id = "outOfStock"]')

    if div_tag is None:
        return False

    span_tags = div_tag.findall(".//span")

    if span_tags is None:
        return False

    try:
        out_of_stock_text = span_tags[0].text
        if "Derzeit nicht verfÃ¼gbar" in out_of_stock_text:
            return True
    except (IndexError, AttributeError):
        pass

    return False


@decorator_for_logging
def _get_name(tree: etree) -> str:
    """select, validate and transform the item name from the given html-tree"""

    # Searching for name_tag on mobile devices
    name_tag = tree.find('.//span[@id = "title"]')

    if name_tag is not None:

        if name_tag.text.strip():
            logging.debug("item name found")
            return name_tag.text.strip()

    # Searching for name_tag on desktop devices
    name_tag = tree.find('.//span[@id = "productTitle"]')

    if name_tag is None:
        logging.error("tag for item name not found in html tree")
        return None

    if name_tag.text.strip():
        logging.debug("item name found")
        return name_tag.text.strip()

    logging.error("item name is empty")

    return None


@decorator_for_logging
def _get_current_price(tree: etree) -> float:
    """select, validate and transform the item current_price from the given html-tree"""

    price_tag = tree.find(
        './/div[@class = "a-section aok-hidden twister-plus-buying-options-price-data"]'
    )

    if price_tag is None:
        logging.error("tag for item current_price not found in html tree")
        return None

    try:
        price: str = price_tag.text.split('"priceAmount":')[1].split(",")[0]

        if price.strip() and price is not None:
            logging.debug("item current_price found")

            if re.match(r"[0-9]+\.[0-9][0-9]", price):
                return float(price)

            logging.warning("Item current_price has a wrong format")
            return float(price)

        logging.error("item current_price is empty")

    except (AttributeError, IndexError):
        logging.error("Error during parsing current_price tag")

    return None


@decorator_for_logging
def _get_sold_by_amazon(tree: etree) -> bool:
    """select, validate and transform the item sold_by_amazon from the given html-tree"""

    div_tag = tree.find('.//div[@id = "merchant-info"]')

    if div_tag is None:
        logging.error("tag for item sold_by_amazon not found in html tree")
        return False

    try:
        seller_tag = div_tag.find("span")
        seller: str = seller_tag.text
        seller = seller.split(" ")[-1].replace(".", "")

        if "Amazon" in seller:
            return True
        return False

    except (AttributeError, IndexError):
        logging.error("Error during parsing sold_by_amazon tag")

    return None


@decorator_for_logging
def _get_date(datetime_now: datetime) -> str:
    """Returns the date part of the given datetime"""

    date = datetime_now.strftime("%Y-%m-%d")
    return date


@decorator_for_logging
def _get_time(datetime_now: datetime) -> str:
    """Returns the time part of the given datetime"""

    current_time = datetime_now.strftime("%H:%M:%S")
    return current_time


@decorator_for_logging
def _get_timestamp(datetime_now: datetime) -> float:
    """Returns the unix timestamp of the given datetime"""

    timestamp = datetime.timestamp(datetime_now)
    return timestamp


@decorator_for_logging
def _get_url(url: str) -> str:
    """validate the given url"""

    if re.match("^https://www.amazon.de", url):
        return url

    logging.warning("Item url doesn`t start with https://www.amazon.de")
    return url


@decorator_for_logging
def _get_asin(tree: etree) -> str:
    """select, validate and transform the item asin from the given html-tree"""

    asin_tag = tree.find('.//input[@id = "ASIN"]')

    if asin_tag is None:
        logging.error("tag for item asin not found in html tree")
        return None

    try:
        asin: str = asin_tag.attrib["value"]

        if asin.strip() and asin is not None:
            logging.debug("item asin found")

            if re.match("^([0-9]|[A-Z])+$", asin):
                return asin

            logging.warning("Item asin has a wrong format")
            return asin

        logging.error("item asin is empty")

    except AttributeError:
        logging.error("Error during parsing asin tag")

    return None


@decorator_for_logging
def _get_seller(tree: etree) -> str:
    """select, validate and transform the item seller from the given html-tree"""

    if _get_sold_by_amazon(tree):
        return "Amazon"

    div_tag = tree.find('.//div[@id = "merchant-info"]')

    if div_tag is None:
        logging.error("tag for item seller not found in html tree")
        return None

    try:
        anchor_tag = div_tag.find("a")
        seller_tag = anchor_tag.find("span")
        seller: str = seller_tag.text

        if seller.strip() and seller is not None:
            logging.debug("item seller found")
            return seller

        logging.error("item seller is empty")

    except AttributeError:
        logging.error("Error during parsing seller tag")

    return None


@decorator_for_logging
def _get_discount_in_euros(tree: etree) -> float:
    """Calling methods to select, validate and transform the item discount_in_euros from the given html-tree"""

    discount: float = _get_discount_in_euros_from_table(tree)

    if discount is None:
        discount = _calculate_discount_in_euros(tree)

    return discount


@decorator_for_logging
def _get_discount_in_euros_from_table(tree: etree) -> float:
    """select, validate and transform the item discount_in_euros from the given html-tree"""

    table_data_tag = tree.find('.//td[@class = "a-span12 a-color-price a-size-base"]')

    if table_data_tag is None:
        return None

    discount_tag = table_data_tag.find('.//span[@class = "a-offscreen"]')

    if discount_tag is None:
        return None

    try:
        # Replacing non-numeric characters with blanks -> Stripping all leading and following whitespaces
        # -> replacing the blank in the middle of the number with a dot
        discount: str = re.sub(r"\D", " ", discount_tag.text)
        discount = re.sub(" ", ".", discount.strip())

        if (
            (re.match(r"[0-9]+\.[0-9][0-9]", discount))
            or (re.match(r"[0-9]+\.[0-9]", discount))
            or (discount.isalnum())
            and (discount is not None)
        ):
            logging.debug("item discount_in_euros found")
            return float(discount)
    except (TypeError, AttributeError, ValueError):
        pass

    return None


@decorator_for_logging
def _calculate_discount_in_euros(tree: etree) -> float:
    """Calculating item discount_in_euros using above implemented methods"""

    price: float = _get_current_price(tree)
    regular_price: float = _get_regular_price(tree)

    if price is None or regular_price is None:
        logging.error("Can`t calculate item discount_in_euros")
        return None

    if price == regular_price:
        return None

    try:
        discount_in_euros = regular_price - price
        return round(discount_in_euros, 2)

    except TypeError:
        logging.error("Error during calculating item discount_in_euros")

    return None


@decorator_for_logging
def _get_percent_discount(tree: etree) -> float:
    """Calling methods to select, validate and transform the item discount_in_euros from the given html-tree"""

    percent_discount: float = _get_percent_discount_from_table(tree)

    if percent_discount is None:
        percent_discount = _get_percent_discount_from_span_tag(tree)

    if percent_discount is None:
        percent_discount = _calculate_percent_discount(tree)

    return percent_discount


@decorator_for_logging
def _get_percent_discount_from_table(tree: etree) -> float:
    """select, validate and transform the item percent_discount from the given html-tree"""

    table_data_tag = tree.find('.//td[@class = "a-span12 a-color-price a-size-base"]')

    if table_data_tag is None:
        return None

    discount_tag = table_data_tag.find('.//span[@data-a-color = "price"]')

    if discount_tag is None:
        return None

    try:
        # Replacing non numeric characters with blanks -> Stripping all leading and following withespaces
        # -> replacing the blank in the middle of the number with a dot
        discount: str = re.sub(r"\D", " ", discount_tag.tail)
        discount = re.sub(" ", ".", discount.strip())

        if (
            (re.match(r"[0-9]+\.[0-9][0-9]", discount))
            or (re.match(r"[0-9]+\.[0-9]", discount))
            or (discount.isalnum())
            and (discount is not None)
        ):
            logging.debug("item percent_discount found")
            return float(discount)

    except (TypeError, AttributeError, ValueError):
        pass

    return None


@decorator_for_logging
def _get_percent_discount_from_span_tag(tree: etree) -> float:
    """select, validate and transform the item percent_discount from the given html-tree"""

    span_tag = tree.find(
        './/span[@class = "a-size-large a-color-price savingPriceOverride aok-align-center reinventPriceSavings'
        'PercentageMargin savingsPercentage"]'
    )
    if span_tag is None:
        return None

    try:
        discount: str = re.sub(r"\D", " ", span_tag.text)
        discount = re.sub(" ", ".", discount.strip())

        if (
            (re.match(r"[0-9]+\.[0-9][0-9]", discount))
            or (re.match(r"[0-9]+\.[0-9]", discount))
            or (discount.isalnum())
            and (discount is not None)
        ):
            logging.debug("item percent_discount found")
            return float(discount)

    except (TypeError, AttributeError, ValueError):
        pass

    return None


@decorator_for_logging
def _calculate_percent_discount(tree: etree) -> float:
    """Calculating item percent_discount using above implemented methods"""

    price: float = _get_current_price(tree)
    regular_price: float = _get_regular_price(tree)

    if (price is None) or (regular_price is None) or (regular_price == 0.0):
        logging.error("Can`t calculate item percent_discount")
        return None

    if price == regular_price:
        return None

    try:
        discount_in_euros = regular_price - price
        percent_discount = discount_in_euros * 100 / regular_price
        return round(percent_discount, 2)

    except (TypeError, ZeroDivisionError):
        logging.error("Error during calculating item percent_discount")

    return None


@decorator_for_logging
def _get_prime(tree: etree) -> bool:
    """select, validate and transform the item prime from the given html-tree"""

    div_tag = tree.find('.//div[@id = "bbop-sbbop-container"]')

    if div_tag is not None:
        return True
    return False


@decorator_for_logging
def _get_regular_price(tree: etree) -> float:
    """select, validate and transform the item regular_price from the given html-tree"""

    span_tag = tree.find(
        './/span[@class = "a-size-small a-color-secondary aok-align-center basisPrice"]'
    )

    if (span_tag is None) or ("Unverb. Preisempf.:" not in span_tag.text):
        logging.info(
            "item regular price not found -> calling function for item current price"
        )
        return _get_current_price(tree)

    current_price_tag = span_tag.find('.//span[@class = "a-offscreen"]')

    if current_price_tag is None:
        logging.info(
            "item regular price not found -> calling function for item current price"
        )
        return _get_current_price(tree)

    try:
        # Replacing non numeric characters with blanks -> Stripping all leading and following withespaces
        # -> replacing the blank in the middle of the number with a dot
        current_price: str = current_price_tag.text
        current_price = re.sub(r"\D", " ", current_price)
        current_price = re.sub(" ", ".", current_price.strip())

        if (
            (re.match(r"[0-9]+\.[0-9][0-9]", current_price))
            or (re.match(r"[0-9]+\.[0-9]", current_price))
            or (current_price.isalnum())
            and (current_price is not None)
        ):
            logging.debug("item regular_price found")
            return float(current_price)

        logging.warning("item regular_price is empty")

    except (TypeError, AttributeError, ValueError):
        logging.warning("Can not parse item regular_price")

    logging.info(
        "item regular price not found -> calling function for item current price"
    )
    return _get_current_price(tree)


@decorator_for_logging
def _get_amazon_choice(tree: etree) -> bool:
    """select, validate and transform the item amazon_choice from the given html-tree"""

    div_tag = tree.find('.//div[@id = "acBadge_feature_div"]')

    if div_tag is None:
        logging.error("tag for item amazon_choice not found in html tree")
        return False

    span_tags = div_tag.findall("div/span/span/span")

    if span_tags is not None and len(span_tags) > 1:
        return True
    return False


@decorator_for_logging
def _get_amazon_choice_for(tree: etree):
    """select, validate and transform the item amazon_choice_for from the given html-tree"""

    if not _get_amazon_choice(tree):
        return None

    div_tag = tree.find('.//div[@id = "acBadge_feature_div"]')
    anchor_tag = div_tag.find(".//a")

    if anchor_tag is None:
        logging.error("tag for item amazon_choice_for not found in html tree")
        return False

    try:
        amazon_choice_for = anchor_tag.text

        if amazon_choice_for:
            return amazon_choice_for
    except (TypeError, AttributeError):
        logging.warning("Can not parse item amazon_choice_for")
    return None


@decorator_for_logging
def _get_shipping(tree: etree) -> float:
    """select, validate and transform the item shipping from the given html-tree"""

    span_tag = tree.find(".//span[@data-csa-c-delivery-price]")

    if span_tag is None:
        return None
    try:
        shipping: str = span_tag.attrib["data-csa-c-delivery-price"]
        shipping = re.sub(r"\D", " ", shipping)
        shipping = re.sub(" ", ".", shipping.strip())

        if (
            (re.match(r"[0-9]+\.[0-9][0-9]", shipping))
            or (re.match(r"[0-9]+\.[0-9]", shipping))
            or (shipping.isalnum())
            and (shipping is not None)
        ):
            return float(shipping)
        return None
    except (TypeError, AttributeError, ValueError):
        logging.warning("Can not parse item shipping")

    return None


@decorator_for_logging
def _get_number_of_reviews(tree: etree):
    """select, validate and transform the item number_of_reviews from the given html-tree"""

    span_tag = tree.find('.//span[@id = "acrCustomerReviewText"]')

    if span_tag is None:
        return None
    try:
        number_of_reviews: str = re.sub(r"\D", " ", span_tag.text)
        number_of_reviews = number_of_reviews.replace(" ", "")

        if (re.match(r"[0-9]+", number_of_reviews)) and (number_of_reviews is not None):
            return int(number_of_reviews)
        return None
    except (TypeError, AttributeError, ValueError):
        logging.warning("Can not parse item number_of_reviews")

    return None


@decorator_for_logging
def _get_review_score(tree: etree):
    """select, validate and transform the item review_score from the given html-tree"""

    span_tag = tree.find('.//span[@id = "acrPopover"]')

    if span_tag is None:
        return None
    try:
        review_score: str = span_tag.attrib["title"].split(" ")[0]

        if (re.match(r"[0-9],[0-9]", review_score)) and (review_score is not None):
            return review_score
        return None
    except (TypeError, AttributeError, IndexError):
        logging.warning("Can not parse item review_score")

    return None


@decorator_for_logging
def _get_product_dimensions(tree: etree):
    """Calling methods to select, validate and transform the item discount_in_euros from the given html-tree"""
    product_dimension = _get_product_dimensions_from_list(tree)

    if product_dimension is None:
        product_dimension = _get_product_dimensions_from_table(tree)

    if product_dimension is None:
        product_dimension = _get_product_dimensions_from_div(tree)

    return product_dimension


@decorator_for_logging
def _get_product_dimensions_from_list(tree: etree):
    """select, validate and transform the item product_dimensions from the given html-tree"""

    div_tag = tree.find('.//div[@id = "detailBulletsWrapper_feature_div"]')

    if div_tag is None:
        return None

    span_tags = div_tag.findall('.//span[@class = "a-list-item"]')

    if div_tag is None:
        return None

    for list_item in span_tags:
        try:
            if (
                list_item.find('.//span[@class = "a-text-bold"]')
                .text.strip()
                .startswith("Produktabmessungen")
            ):
                return (list_item.findall(".//span")[1]).text
        except (TypeError, AttributeError, IndexError):
            logging.warning("Can not parse item product_dimensions")

    return None


@decorator_for_logging
def _get_product_dimensions_from_table(tree: etree):
    """select, validate and transform the item product_dimensions from the given html-tree"""

    table_tag = tree.find('.//table[@id = "productDetails_techSpec_section_1"]')

    if table_tag is None:
        return None

    table_row_tags = table_tag.findall(".//tr")

    if table_row_tags is None:
        return None

    for table_item in table_row_tags:
        try:
            if table_item.find(".//th").text.strip().startswith("Produktabmessungen"):
                product_dimension = (table_item.find(".//td")).text
                return product_dimension.replace("\u200e", "").strip()
        except (TypeError, AttributeError):
            logging.warning("Can not parse item product_dimensions")

    return None


@decorator_for_logging
def _get_product_dimensions_from_div(tree: etree):
    """select, validate and transform the item product_dimensions from the given html-tree"""

    div_tag_id = tree.find('.//div[@id = "tech"]')

    if div_tag_id is None:
        return None

    try:
        div_tag_class = div_tag_id.findall(
            './/div[@class = "content-grid-row-wrapper "]'
        )[3]
    except IndexError:
        return None

    if div_tag_class is None:
        return None

    table_rows = div_tag_class.findall(".//tr")

    for table_item in table_rows:
        try:
            if table_item.find(".//strong").text.strip().startswith("Abmessungen"):
                return (table_item.findall(".//p")[1]).text
        except (TypeError, AttributeError, IndexError):
            logging.warning("Can not parse item product_dimensions")

    return None


@decorator_for_logging
def _get_brand(tree: etree):
    """select, validate and transform the item brand from the given html-tree"""

    div_tag = tree.find('.//div[@id = "bylineInfo_feature_div"]')

    if div_tag is None:
        return None

    anchor_tag = div_tag.find(".//a")

    if anchor_tag is None:
        return None

    try:
        if "Amazon" in anchor_tag.text:
            return "Amazon"
        return anchor_tag.text.split("den ")[1].replace("-Store", "")
    except (TypeError, AttributeError, IndexError):
        logging.warning("Can not parse item brand")

    return None


@decorator_for_logging
def _get_product_id(tree: etree):
    """select, validate and transform the item product_id from the given html-tree"""

    if _get_brand(tree) == "Amazon":
        return None

    product_id = _get_product_id_from_list(tree)

    if product_id is None:
        product_id = _get_product_id_from_table(tree)

    return product_id


@decorator_for_logging
def _get_product_id_from_list(tree: etree):
    """select, validate and transform the item product_id from the given html-tree"""

    div_tag = tree.find('.//div[@id = "detailBulletsWrapper_feature_div"]')

    if div_tag is None:
        return None

    span_tags = div_tag.findall('.//span[@class = "a-list-item"]')

    if div_tag is None:
        return None

    for list_item in span_tags:
        try:
            if list_item.find(
                './/span[@class = "a-text-bold"]'
            ).text.strip().startswith("Modellnummer") or list_item.find(
                './/span[@class = "a-text-bold"]'
            ).text.strip().startswith(
                "Teilenummer"
            ):
                return (list_item.findall(".//span")[1]).text
        except (TypeError, AttributeError, IndexError):
            logging.warning("Can not parse item product_id")

    return None


@decorator_for_logging
def _get_product_id_from_table(tree: etree):
    """select, validate and transform the item product_id from the given html-tree"""

    table_tag = tree.find('.//table[@id = "productDetails_techSpec_section_1"]')

    if table_tag is None:
        return None

    table_row_tags = table_tag.findall(".//tr")

    if table_row_tags is None:
        return None

    for table_item in table_row_tags:
        try:
            if table_item.find(".//th").text.strip().startswith(
                "Modellnummer"
            ) or table_item.find(".//th").text.strip().startswith("Teilenummer"):
                product_dimension = (table_item.find(".//td")).text
                return product_dimension.replace("\u200e", "").strip()
        except (TypeError, AttributeError):
            logging.warning("Can not parse item product_id")

    return None


@decorator_for_logging
def _get_manufacturer(tree: etree):
    """select, validate and transform the item manufacturer from the given html-tree"""

    manufacturer = _get_manufacturer_from_list(tree)

    if manufacturer is None:
        manufacturer = _get_manufacturer_from_table(tree)

    return manufacturer


@decorator_for_logging
def _get_manufacturer_from_list(tree: etree):
    """select, validate and transform the item manufacturer from the given html-tree"""

    div_tag = tree.find('.//div[@id = "detailBulletsWrapper_feature_div"]')

    if div_tag is None:
        return None

    span_tags = div_tag.findall('.//span[@class = "a-list-item"]')

    if div_tag is None:
        return None

    for list_item in span_tags:
        try:
            if (
                list_item.find('.//span[@class = "a-text-bold"]')
                .text.strip()
                .startswith("Hersteller")
            ):
                return list_item.findall(".//span")[1].text
        except (TypeError, AttributeError, IndexError):
            logging.warning("Can not parse item manufacturer")

    return None


@decorator_for_logging
def _get_manufacturer_from_table(tree: etree):
    """select, validate and transform the item manufacturer from the given html-tree"""

    table_tag = tree.find('.//table[@id = "productDetails_techSpec_section_1"]')

    if table_tag is None:
        return None

    table_row_tags = table_tag.findall(".//tr")

    if table_row_tags is None:
        return None

    for table_item in table_row_tags:
        try:
            if table_item.find(".//th").text.strip().startswith("Hersteller"):
                product_dimension = table_item.find(".//td").text
                return product_dimension.replace("\u200e", "").strip()
        except (TypeError, AttributeError):
            logging.warning("Can not parse item manufacturer")

    return None


@decorator_for_logging
def _get_country_of_origin(tree: etree):
    """select, validate and transform the item country_of_origin from the given html-tree"""

    country_of_origin = _get_country_of_origin_from_list(tree)

    if country_of_origin is None:
        country_of_origin = _get_country_of_origin_from_table(tree)

    return country_of_origin


@decorator_for_logging
def _get_country_of_origin_from_list(tree: etree):
    """select, validate and transform the item country_of_origin from the given html-tree"""
    div_tag = tree.find('.//div[@id = "detailBulletsWrapper_feature_div"]')

    if div_tag is None:
        return None

    span_tags = div_tag.findall('.//span[@class = "a-list-item"]')

    if div_tag is None:
        return None

    for list_item in span_tags:
        try:
            if (
                list_item.find('.//span[@class = "a-text-bold"]')
                .text.strip()
                .startswith("Herkunftsland")
            ):
                return (list_item.findall(".//span")[1]).text
        except (TypeError, AttributeError, IndexError):
            logging.warning("Can not parse item country_of_origin")

    return None


@decorator_for_logging
def _get_country_of_origin_from_table(tree: etree):
    """select, validate and transform the item manufacturer from the given html-tree"""

    table_tag = tree.find('.//table[@id = "productDetails_techSpec_section_1"]')

    if table_tag is None:
        return None

    table_row_tags = table_tag.findall(".//tr")

    if table_row_tags is None:
        return None

    for table_item in table_row_tags:
        try:
            if table_item.find(".//th").text.strip().startswith("Herkunftsland"):
                product_dimension = (table_item.find(".//td")).text
                return product_dimension.replace("\u200e", "").strip()
        except (TypeError, AttributeError):
            logging.warning("Can not parse item manufacturer")

    return None


@decorator_for_logging
def _get_on_sale_since(tree: etree):
    """select, validate and transform the item on_sale_since from the given html-tree"""

    on_sale_since = _get_on_sale_since_from_list(tree)

    if on_sale_since is None:
        on_sale_since = _get_on_sale_since_from_table(tree)

    return on_sale_since


@decorator_for_logging
def _get_on_sale_since_from_list(tree: etree):
    """select, validate and transform the item on_sale_since from the given html-tree"""

    div_tag = tree.find('.//div[@id = "detailBulletsWrapper_feature_div"]')

    if div_tag is None:
        return None

    span_tags = div_tag.findall('.//span[@class = "a-list-item"]')

    if div_tag is None:
        return None

    for list_item in span_tags:
        try:
            if (
                list_item.find('.//span[@class = "a-text-bold"]')
                .text.strip()
                .startswith("Im Angebot von Amazon.de seit")
            ):

                locale.setlocale(locale.LC_TIME, "de_DE")
                date_format = "%d. %B %Y"

                date = (list_item.findall(".//span")[1]).text

                new_date = time.strptime(date, date_format)

                return (
                    str(new_date.tm_mday)
                    + "."
                    + str(new_date.tm_mon)
                    + "."
                    + str(new_date.tm_year)
                )
        except (TypeError, AttributeError, IndexError):
            logging.warning("Can not parse item on_sale_since")

    return None


@decorator_for_logging
def _get_on_sale_since_from_table(tree: etree):
    """select, validate and transform the item on_sale_since from the given html-tree"""

    table_tag = tree.find('.//table[@id = "productDetails_detailBullets_sections1"]')

    if table_tag is None:
        return None

    table_row_tags = table_tag.findall(".//tr")

    if table_row_tags is None:
        return None

    for table_item in table_row_tags:
        try:
            if (
                table_item.find(".//th")
                .text.strip()
                .startswith("Im Angebot von Amazon.de seit")
            ):

                date = (table_item.find(".//td")).text
                date = date.replace("\u200e", "").strip()

                locale.setlocale(locale.LC_TIME, "de_DE")
                date_format = "%d. %B %Y"

                new_date = time.strptime(date, date_format)

                return (
                    str(new_date.tm_mday)
                    + "."
                    + str(new_date.tm_mon)
                    + "."
                    + str(new_date.tm_year)
                )
        except (TypeError, AttributeError):
            logging.warning("Can not parse item on_sale_since")

    return None
